---
id: ba-257c
status: open
deps: [ba-dca5, ba-d968]
links: []
created: 2026-01-29T18:11:01Z
type: task
priority: 0
assignee: vot3k
parent: ba-3d4c
---
# Implement VM lifecycle handlers (CRUD + start/stop)

## Objective
Implement all VM lifecycle HTTP handlers in internal/api/handlers.go — the core of the vmm-api.

## Location
- New file: internal/api/handlers.go

## Implementation Details

### Handler Pattern
Each handler follows the same flow used by the CLI in cmd/vmm/main.go, but reads from HTTP request bodies and writes JSON responses instead of stdout.

### POST /v1/vms — Create VM
**Request body:**
```json
{
  "name": "worker-1",
  "cpus": 2,
  "memory_mb": 1024,
  "disk_size_mb": 4096,
  "ssh_public_key": "ssh-ed25519 AAAA...",
  "dns_servers": ["8.8.8.8"],
  "image": "ubuntu-base",
  "kernel": "kernel-6.1",
  "mounts": [
    {"host_path": "/data/code", "guest_tag": "code", "read_only": false}
  ]
}
```
**Logic (mirrors createCmd in main.go):**
1. Parse and validate request body
2. Check vm.Exists() — return 409 Conflict if duplicate
3. Create VM with vm.NewVM(name), set fields from request
4. Apply defaults from config (same logic as CLI: request field → config default → hardcoded)
5. Allocate IP via netMgr.AllocateIP()
6. Generate TAP name and MAC address
7. Save VM via vm.Save()
8. Return 201 with VM data

### GET /v1/vms — List VMs
**Logic (mirrors listCmd):**
1. Call vm.List(paths.VMs)
2. Update state for each VM via fcClient.UpdateVMState()
3. Return 200 with array of VMs

### GET /v1/vms/{name} — Get VM
**Logic:**
1. Extract name from path: r.PathValue("name")
2. Call vm.Load(paths.VMs, name)
3. Update state via fcClient.UpdateVMState()
4. Return 200 with VM data, or 404 if not found

### DELETE /v1/vms/{name} — Delete VM
**Query params:** ?force=true for force delete
**Logic (mirrors deleteCmd):**
1. Load VM
2. If running and not force: return 409 Conflict "stop VM first"
3. If running and force: stop VM first
4. Remove port forward rules via netMgr
5. Delete mount images via mountMgr
6. Delete rootfs via imgMgr
7. Delete VM config via vm.Delete()
8. Return 200 with deleted VM data

### POST /v1/vms/{name}/start — Start VM
**Logic (mirrors startCmd):**
1. Load VM, verify state is created/stopped
2. Ensure default images exist (imgMgr.EnsureDefaultImages)
3. Create VM rootfs if needed (imgMgr.CreateVMRootfs)
4. Inject SSH key, DNS config, mount fstab
5. Create mount images
6. Ensure bridge (netMgr.EnsureBridge)
7. Create TAP device (netMgr.CreateTap)
8. Build VMConfig, call fcClient.StartVM()
9. Update VM state to running, save
10. Return 200 with updated VM

### POST /v1/vms/{name}/stop — Stop VM
**Logic (mirrors stopCmd):**
1. Load VM, verify state is running
2. Call fcClient.StopVM()
3. Delete TAP device
4. Update state to stopped, save
5. Return 200 with updated VM

### POST /v1/vms/{name}/port-forward — Add Port Forward
**Request body:**
```json
{
  "host_port": 8080,
  "guest_port": 80,
  "protocol": "tcp"
}
```
**Logic (mirrors portForwardCmd):**
1. Load VM, verify running
2. Call netMgr.AddPortForward()
3. Add to VM.PortForwards, save
4. Return 200

## Key Implementation Notes
- All handlers acquire s.mu.Lock() for mutations or s.mu.RLock() for reads
- Use WriteJSON/WriteError helpers from responses.go
- Parse request bodies with json.NewDecoder(r.Body).Decode()
- Set request body size limit: http.MaxBytesReader(w, r.Body, 1<<20) (1MB)
- Extract path params with r.PathValue("name") (Go 1.22+)
- Mirror the exact business logic from cmd/vmm/main.go — the internal packages are already tested

## Acceptance Criteria
- All 7 VM endpoints implemented with correct HTTP methods and status codes
- Request validation returns 400 with descriptive error for invalid inputs
- VM create returns 409 if name already exists
- Start/stop enforce correct state transitions
- Delete with force=true stops running VM first
- JSON responses match RFC envelope format

## Acceptance Criteria

All 7 VM endpoints work via curl; create returns 201; duplicate returns 409; invalid returns 400

